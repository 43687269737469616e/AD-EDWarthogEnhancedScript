//==============================================================================================================================================================//
// VERSION 5.0.0									 \\ Released Sept 2016	|	Updated ?? 2021 //											Public Release #26	//
//==============================================================================================================================================================//
//													///  Aussiedroid's Enhanced Warthog Script  \\\																//
//==============================================================================================================================================================//
// TOC:/					[1. INITIALISATION / STARTUP  ]		[2. HOTAS CONTROL MAPPING	 ]		[3. HARDWARE HANDLER		  ]								//
//-----							- INCLUDED FILES	  (12)			- JOYSTICK 			(143)			- EVENT HANDLE	 (492)									//
//								- DEVICE CHECK		  (25)			- THROTTLE ARM 		(329)																	//
//								- START SOFTWARE	  (49)			- THROTTLE BASE		(404)																	//
//								- CORE SETTINGS		  (65)					        																			//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// INCLUDED FILES //
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	include "Target.tmh" 													// Mandatory System Default Import (Thrustmaster TARGET Functions)
	include "AD_EDDefaults_v5.0.0.tmh"										// Global Variable Settings, Flags, States & Timings/Delays
	include "AD_EDUserPrefs_v5.0.0.tmh" 									// User Preferences, Script Customisation Options, Readme & Patch Notes
	include "AD_EDKeyMap_v5.0.0.ttm" 										// Variable Key Mapping & Reference Tables
	include "AD_EDHardware_v5.0.0.tmh"										// MFD, Joystick, Throttle & Rudder Axes/Curves Configuration
	include "AD_EDStatusJson_v5.0.0.tmh"									// Parse Status.json file to get real-time in-game status
	include "AD_EDMacros_v5.0.0.tmh"										// Macro Definitions	 (Custom Sequences)
	include "AD_EDFunctions_v5.0.0.tmh" 									// Function Definitions	 (Custom Logic for Buttons, Toggles & Ship Controls)

//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// START-UP: DEVICE CHECK / MAIN //
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	int main() {
		Configure(&HCougar,		  MODE_EXCLUDED);							// Exclude Hardware from Virtual Device & Manage Additional Devices
		Configure(&T16000,		  MODE_EXCLUDED);
		Configure(&T16000L,		  MODE_EXCLUDED);
		Configure(&JoystickF18,	  MODE_EXCLUDED);
		Configure(&A320Pilot,	  MODE_EXCLUDED);
		Configure(&A320Copilot,	  MODE_EXCLUDED);
		Configure(&TCAQuadrant12, MODE_EXCLUDED);
		Configure(&TCAQuadrant34, MODE_EXCLUDED);		
		
		if(UseMFD == 0) {													// No MFDs (Exclude configuring MFDs unless set in User Preferences)
			Configure(&LMFD, 	  MODE_EXCLUDED);
			Configure(&RMFD, 	  MODE_EXCLUDED); }
		if(UseRuddersT16000 == 0) Configure(&TFRPRudder,	MODE_EXCLUDED);	// Enables Standard T.Flight T16000 Rudders
		if(UseRuddersT16000 == 1) Configure(&TFRPRudder,	MODE_FILTERED);	// Enables Differential Toe Brakes on T.Flight T16000 Rudders (for mapping through Target Script)
		if(UseRuddersTPR == 0)	  Configure(&TFRPHARudder,	MODE_EXCLUDED);	// Enables Standard T.Flight TPR Pedals
		if(UseRuddersTPR == 1)	  Configure(&TFRPHARudder,	MODE_FILTERED);	// Enables Differential Toe Brakes on T.Flight TPR Pedals (for mapping through Target Script)Configure(&TFRPHARudder, MODE_FILTERED);

	if(Init(&EventHandle)) return 1;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// START-UP: SOFTWARE (LEGACY) //  (*May not work on Win 10* - Use EDBAT instead)		// *system("spawn -w \"software main folder" \"exe shortcut"");  
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	if(StartSoftware == 1) {															// Auto-Load on Script Run (Customise Example Paths below OR Add Your Own)
		if(VerboseOutput) printf("Booting external software suite for Elite Dangerous...Done\x0a");		//	   (Note: All path '\' need to be '\\' for it to work)
//		system("spawn -w \"C:\\Program Files (x86)\\NaturalPoint\\TrackIR5\" \"C:\\Program Files (x86)\\NaturalPoint\\TrackIR5\\TrackIR5.exe\"");			// TRACKIR			(URL= http://www.naturalpoint.com/trackir/)
//		system("spawn -w \"C:\\Program Files (x86)\\VoiceAttack\" \"C:\\Program Files (x86)\\VoiceAttack\\VoiceAttack.exe\"");								// VOICE ATTACK		(URL= https://voiceattack.com/)
//		system("spawn -w \"C:\\Program Files (x86)\\VoiceAttack\\Apps\\EDDI\" \"C:\\Program Files (x86)\\VoiceAttack\\Apps\\EDDI\\EDDI.exe"");				// EDDI				(URL= https://github.com/EDCD/EDDI/wiki)
//		system("spawn -w \"C:\\Program Files (x86)\\EDMarketConnector\" \"C:\\Program Files (x86)\\EDMarketConnector\\EDMarketConnector.exe\"");			// EDMC				(URL= https://github.com/Marginal/EDMarketConnector/wiki)
//		system("spawn -w \"C:\\Program Files (x86)\\EDDiscovery\" \"C:\\Program Files (x86)\\EDDiscovery\\EDDiscovery.exe\"");								// EDDISCOVERY		(URL= https://github.com/EDDiscovery/EDDiscovery/wiki)
//		system("spawn -w \"C:\\Program Files\\EDFX\" \"C:\\Program Files\\EDFX\\EDFX64.exe\"");																// EDFX				(URL= http://edcodex.info/?m=tools&entry=58)
//		system("spawn -w \"C:\\Users\\<USERNAME>\\AppData\\Local\\Discord\" \"C:\\Users\\<USERNAME>\\AppData\\Local\\Discord\\app-0.0.297\\Discord.exe\"");	// DISCORD			(URL= https://discordapp.com/)
//		system("spawn -w \"C:\\Program Files (x86)\\Steam\\steamapps\\common\\Elite Dangerous\" \"C:\\Program Files (x86)\\Steam\\steamapps\\common\\Elite Dangerous\\EDLaunch.exe\""); // ELITE DANGEROUS LAUNCHER
		}

//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// CORE SETTINGS: INITIALISATION //
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	AxisCurveMod = LIST(0,0, 33,25, 66,50, 80,75, 100,100);									// Creates a custom axis curve for Throttle & Radar. [Faster->Slower Curve] (See AD_EDHardware.tmh) *LIST(Axis physical position, Axis output Value)

	SetKBRate(PulseTime, DelayTime);														// Base Settings 	(See AD_EDDefaults.tmh)
	SetKBLayout(KBLayout);


	// FUNCTION START //
	initCustomMacroCommands();																// Initiate Custom Macros & Functions (See AD_EDMacros.tmh)
	initEscapeVector();																		// Initiate Advanced Macro to perform a tactical withdraw from combat (Retract Hardpoints, Set Defensive PIPs, Auto Boost/Chaff, Engage Supercruise) (See AD_EDMacros.tmh)
	initAutoVehicleTransition();															// Initiate Swapping Vehicle Ship<=>SRV. Will Embark or Board depending what vehicle you are in at the time. (See AD_EDFunctions.tmh)
	initSetThrottleCurves();																// Initiate Mapping of Custom Throttle Curves (3 Presets configurable in AD_EDUserPrefs.tmh)
	initJsonStartCheck();																	// Initiate Check for status.json file & commence reading output to flags (See AD_EDStatusJson.tmh)
	initPrintState();																		// Initiate Display Script Settings to Output Window in Script/GUI (See AD_EDFunctions.tmh)
	initPIPMapper();																		// Initiate PIP Configuration Mapper (See AD_EDFunctions.tmh)
	initSetCombinedFire(0);																	// Initiate Mapping Logic to enable/disable the Dual-Stage Primary Trigger with either Primary & Secondary Fire Combined OR Primary Fire Only (Nothing mapped to 2nd stage). (See AD_EDFunctions.tmh)
	initToggleRotationCorrection();															// Initiate Toggle Mapping for Rotational Correction (LED Support) (See AD_EDFunctions.tmh)
	initToggleSilentRunning(0);																// Initiate Toggle Mapping for Silent Running		 (LED Support) (See AD_EDFunctions.tmh)
	initEnhancedFAOFF();																	// Initiate Toggle Mapping for Flight Assist Off	 (LED Support, Auto-Joystick Curve adjust) (See AD_EDFunctions.tmh)
	initToggleLandingGear(0);																// Initiate Toggle Mapping for Landing Gear			 (LED Support) (See AD_EDFunctions.tmh)
	initToggleCargoScoop(0);																// Initiate Toggle Mapping for Cargo Scoop			 (LED Support) (See AD_EDFunctions.tmh)
	initCargoReturnMode();																	// Initiate Disables Cargo Scoop Throttle Mode		 (LED Support) (See AD_EDFunctions.tmh)
	initIDLEMaster();																		// Initiate Advanced Function to disable Throttle (& Boost) when engaging Throttle IDLE/Afterburner Lock Indent. Will also enable SRV Handbrake. (See AD_EDFunctions.tmh)
	initHeadlookModeSelect();																// Initiate Custom mapping preference for Headlook Centering based on your hardware (TrackIR, VR, Mouse) (See AD_EDFunctions.tmh)
	initFreeCameraModeUpgrade();															// Initiate Custom External Camera Module automatically go to Free Camera with HUD disabled (See AD_EDFunctions.tmh)
	initHardpointManagement();																// Initiate Advanced Function integrating all Hardpoint/Other functions related to the Red Left Throttle Button (See AD_EDFunctions.tmh)
	initMicCommander();																		// Initiate Full control over Internal & External Mic Push-to-Talk functionality for Hold & Toggle configurations (See AD_EDFunctions.tmh)
	initUserHotSlotPinkyTrigger();															// Initiate Double Tap Functionality on the Joystick Pinky Trigger (See AD_EDFunctions.tmh)
	initLEDController(0);																	// Initiate Short LED Flashing Sequence on Toggle Flip & a Pattern on Startup. (LED Support) (See AD_EDFunctions.tmh)
	initAPEngageEnhancer();																	// Initiate Autopilot Engage button customisation				   (See AD_EDFunctions.tmh) (includes Auto-Dock & Signal Light Macros)
	initExplorerScannerDisengage();															// Initiate Repeater Fire Explorer-Scanner Disengage/Off Console Printout (See AD_EDFunctions.tmh)


	// HARDWARE CONFIG //
	initJoystickAxis();																		// Initiate HOTAS Axis Mappings
	initThrottleAxis();

	if(UseMFD > 0)			  initRightMFD();												// Initiate the First MFD Only		(Initialise via HARDWARE: MFD CONTROLS section) (See AD_EDHardware.tmh) *UNTESTED*
	if(UseMFD > 1)			  initLeftMFD();												// Initiate the Second MFD			(Initialise via HARDWARE: MFD CONTROLS section) (See AD_EDHardware.tmh) *UNTESTED*

	if(UseRuddersT16000 == 1) initTFRPRudder();												// Enables T.Flight TFRP T16000 Rudder Intialisation.	(Note: T.Flight Rudder Axes are Configured below in EVENT HANDLER)
	if(UseRuddersTPR == 1)	  initTFRPHARudder();											// Enables T.Flight TPR Pedal Intialisation. 			(Note: T.Flight Rudder Axes are Configured below in EVENT HANDLER)

																							// Syntax: KeyAxis(&Device, axis name, layer(s), AXMAP1(number of zones, up event, down event, optional center event); 
	if(CruiseOnThrottle == 1) KeyAxis(&Throttle, THR_RIGHT, 0, AXMAP1(LIST(0,1,99,100),		// Supercruise on Throttle 100%	/ 0% [Note: Throttle Axis 'Full Range' Curves adjusted -10% when active] (This sets 3 zones on the axis, 0-1%, 1-99%, 99-100% for mapping)
							  EXEC("if(Joystick[S4])  ActKey(KEYON+PULSE+FrameShiftDrive);"	// 99-100% IF Pinky Modifier Held, Activate Hyperspace Jump (Up Event)
								   "if(Joystick[H4P]) ActKey(KEYON+PULSE+Supercruise);"),	// 99-100% IF CMS Modifier Held, Activate Supercruise (Up Event)
							  EXEC("if(Joystick[S4])  ActKey(KEYON+PULSE+FrameShiftDrive);"	//  0-1%   IF Pinky Modifier Held, Activate Hyperspace Jump (Down Event)
								   "if(Joystick[H4P]) ActKey(KEYON+PULSE+Supercruise);"),	//  0-1%   IF CMS Modifier Held, Activate Supercruise (Down Event)
							  0));															//  1-99%  ELSE do nothing (Center Event)


	// AXIS PRESET TOGGLES // 																// Map Flaps Select Toggle to Throttle Axis Presets & Set Overrides
	if(ThrottleOverride == 0) {																// Default Throttle Axis Preset Toggle Configuration
		MapKey(&Throttle, FLAPU,  EXEC("if(!Throttle[IDLELON]) ActKey(KEYON+PULSE+ThrottlePresetUP);")); 	 // Flaps UP  	 (Safety: Only Activate When Throttle IDLE is not Locked ON)
		MapKey(&Throttle, FLAPM,  EXEC("if(!Throttle[IDLELON]) ActKey(KEYON+PULSE+ThrottlePresetMID);"));	 // Flaps MIDDLE (Safety: Only Activate When Throttle IDLE is not Locked ON)
		MapKey(&Throttle, FLAPD,  EXEC("if(!Throttle[IDLELON]) ActKey(KEYON+PULSE+ThrottlePresetDOWN);")); } // Flaps DOWN	 (Safety: Only Activate When Throttle IDLE is not Locked ON)
	if(ThrottleOverride == 1) {																// User Configured Throttle Axis Preset Toggle Configuration (set in the User Prefs)
		MapKey(&Throttle, FLAPU,  EXEC("ActKey(KEYON+PULSE+ThrottlePresetUPALT);"));  		// Flaps UP  	(Safety: Only Activate When Throttle IDLE is not Locked ON)
		MapKey(&Throttle, FLAPM,  0); 														// Flaps MIDDLE	(Default: Not mapped to avoid conflicts)
		MapKey(&Throttle, FLAPD,  EXEC("ActKey(KEYON+PULSE+ThrottlePresetDWNALT);")); }		// Flaps DOWN	(Safety: Only Activate When Throttle IDLE is not Locked ON)

																							// Map Throttle Autopilot to Joystick Curve Presets
	if(JoystickOverride == 0) {																// Default Joystick Axis Preset Toggle Configuration
		MapKey(&Throttle, APPAT,  EXEC("initSetJoystickCurves();"));						// Autopilot PATH UP
		MapKey(&Throttle, APAH,   EXEC("initSetJoystickCurves();"));						// Autopilot ALT/HDG MIDDLE (Default)
		MapKey(&Throttle, APALT,  EXEC("initSetJoystickCurves();")); }						// Autopilot ALT DOWN
	if(JoystickOverride == 1) { 															// User Configured Joystick Axis Preset Toggle Configuration (set in the User Prefs)
		if(StartupLock) { 																	// On Startup Only, set the default Joystick Behaviour (set in the User Prefs)
			SetSCurve(&Joystick, JOYX, 0, JS_DEADZONE, 0, JS_CURVE[JoystickPresetDEF], JS_ZOOM[JoystickPresetDEF]);	 // Set Joystick X Axis 
			SetSCurve(&Joystick, JOYY, 0, JS_DEADZONE, 0, JS_CURVE[JoystickPresetDEF], JS_ZOOM[JoystickPresetDEF]);	}// Set Joystick Y Axis
		MapKey(&Throttle, APPAT,  EXEC("ActKey(KEYON+PULSE+JoystickPresetUPALT);"));		// Autopilot PATH UP
		MapKey(&Throttle, APAH,   0);														// Autopilot ALT/HDG MIDDLE (Default: Not mapped to avoid conflicts)
		MapKey(&Throttle, APALT,  EXEC("ActKey(KEYON+PULSE+JoystickPresetDWNALT);")); }		// Autopilot ALT DOWN


//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// MAP JOYSTICK CONTROLS //
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	// PRIMARY FIRE //
	SetShiftButton(&Joystick, S4, &Throttle, PSF, PSB);																// Set Shift Button (Pinky Toggle Switch) for MapKeyIOUMD	(With UDTOGGLE = Toggle, Without = Hold -> See Page 22 of manual)	

	MapKeyIOUMD(&Joystick,  TG1,																					// Trigger 1			[Primary Trigger]
								SEQ( EXEC(				"ActKey(KEYON+DOWN+PrimaryFire);	EndlessStatePri = 1;	if(VerboseOutput) printf(\"Repeater Fire: COMBAT-ENDLESS [ON]  (PRIMARY)\\x0a\");"),					// IU
									 EXEC(				"ActKey(KEYON+UP+PrimaryFire); 		EndlessStatePri = 0;	if(VerboseOutput) printf(\"Repeater Fire: COMBAT-ENDLESS [OFF] (PRIMARY)\\x0a\");")),
								EXEC(					"ActKey(KEYON+DOWN+PrimaryFire);"),																																	// OU
								EXEC("if(!Joystick[H4P]) ActKey(KEYON+DOWN+PrimaryFire);				 			if(VerboseOutput) printf(\"Repeater Fire: EXPLORER-SCANNER [ON]  (PRIMARY)\\x0a\");"					// IM
									 "if(!Joystick[H4P]) DeferCall(ScanTimer, &ActKey, KEYON+UP+PrimaryFire);		DeferCall(ScanTimer, &ActKey, initExplorerScannerDisengage());"
									 "if(Joystick[H4P])	 initSetCombinedFire(1);"),
								EXEC(					"ActKey(KEYON+DOWN+PrimaryFire);"),																																	// OM
								SEQ(REXEC(0, MineTimer,	"ActKey(KEYON+PULSE+PrimaryFire);							if(VerboseOutput) printf(\"Repeater Fire: MINING-AUTO-PULSE [^FIRED^] (PRIMARY)\\x0a\");", RNOSTOP),	// ID
									 EXEC(				"StopAutoRepeat(0); 										if(VerboseOutput) printf(\"Repeater Fire: MINING-AUTO-PULSE [DISABLE] (PRIMARY)\\x0a\");")),
								EXEC(					"ActKey(KEYON+DOWN+PrimaryFire);"));																																// OD
	MapKeyRIOUMD(&Joystick, TG1, 																					// Release Trigger 1	[Primary Trigger]
								0, 	 EXEC("if(!EndlessStatePri)  ActKey(KEYON+UP+PrimaryFire);"),		// IU, OU	// Only Releases if Combat-Endless Mode is NOT enabled (keeps sequence in sync)
								0,	 EXEC("if(!EndlessStatePri)  ActKey(KEYON+UP+PrimaryFire);"),		// IM, OM
								0,	 EXEC("if(!EndlessStatePri)  ActKey(KEYON+UP+PrimaryFire);"));		// ID, OD
//	MapKey(&Joystick,   	TG2, 	 SecondaryFire);																// Trigger 2			[Second Stage Trigger] (Mapped in initHardpointManagement())
//	MapKeyR(&Joystick,  	TG2, 	 EXEC("ActKey(KEYON+UP+SecondaryFire);"));										// Release Trigger 2	[Second Stage Trigger] (Keeps Primary firing after releasing Secondary Tier)
	MapKeyR(&Joystick,  	TG2, 	 EXEC("if(combinePriSecFire) ActKey(KEYON+UP+SecondaryFire);" 					// Release Trigger 2	[Second Stage Trigger]
										  "if(combinePriSecFire) ActKey(KEYON+DOWN+PrimaryFire);"));				//	(Keeps Primary Fire firing after releasing Secondary Tier Trigger)

	// UTILITY SLOTS //
	if(ShipUtilityPref == 0) {
		MapKey(&Joystick,  S1,  TEMPO(PULSE+FireChaffLauncher, PULSE+DeployHeatSink, LongPressDelay)); 				// Master Mode Control 	[Short: Chaff, 			Long: Heat Sink]
		MapKey(&Joystick,  S2,  TEMPO(SRVTurret, PULSE+UseShieldCell, LongPressDelay)); }							// Weapon Release 		[Short: ECM/SRV Turret, Long: Shield Cell]
	if(ShipUtilityPref == 1) {
		MapKey(&Joystick,  S1,  TEMPO(PULSE+DeployHeatSink, PULSE+FireChaffLauncher, LongPressDelay)); 				// Master Mode Control 	[Short: Heat Sink, 	 	Long: Chaff]
		MapKey(&Joystick,  S2,  TEMPO(PULSE+UseShieldCell, SRVTurret, LongPressDelay)); }							// Weapon Release 		[Short: Shield Cell, 	Long: ECM/SRV Turret]


	// SECONDARY FIRE //
	if(SecFirePinkyPref == 0) {
		MapKeyIOUMD(&Joystick,  S3,																					// Pinky Button 		[Secondary Fire]
								SEQ( EXEC(				"ActKey(KEYON+DOWN+SecondaryFire);	EndlessStateSec = 1;	if(VerboseOutput) printf(\"Repeater Fire: COMBAT-ENDLESS [ON]  (SECONDARY)\\x0a\");"),						// IU
									 EXEC(				"ActKey(KEYON+UP+SecondaryFire); 	EndlessStateSec = 0;	if(VerboseOutput) printf(\"Repeater Fire: COMBAT-ENDLESS [OFF] (SECONDARY)\\x0a\");")),
								EXEC(					"ActKey(KEYON+DOWN+SecondaryFire);"),																																	// OU
								EXEC(					"ActKey(KEYON+DOWN+SecondaryFire);				 			if(VerboseOutput) printf(\"Repeater Fire: EXPLORER-SCANNER [ON]  (SECONDARY)\\x0a\");"						// IM
									 					"DeferCall(ScanTimer, &ActKey, KEYON+UP+SecondaryFire);		DeferCall(ScanTimer, &ActKey, initExplorerScannerDisengage());"),
								EXEC(					"ActKey(KEYON+DOWN+SecondaryFire);"),																																	// OM
								SEQ(REXEC(0, MineTimer,	"ActKey(KEYON+PULSE+SecondaryFire);							if(VerboseOutput) printf(\"Repeater Fire: MINING-AUTO-PULSE [^FIRED^] (SECONDARY)\\x0a\");", RNOSTOP),		// ID
									 EXEC(				"StopAutoRepeat(0); 										if(VerboseOutput) printf(\"Repeater Fire: MINING-AUTO-PULSE [DISABLE] (SECONDARY)\\x0a\");")),
								EXEC(					"ActKey(KEYON+DOWN+SecondaryFire);"));																																	// OD
		MapKeyRIOUMD(&Joystick, S3, 																				// Release Pinky Button	[Secondary Fire]
								0, 	 EXEC("if(!EndlessStateSec)  ActKey(KEYON+UP+SecondaryFire);"),		// IU, OU	// Only Releases if Combat-Endless Mode is NOT enabled (keeps sequence in sync)
								0,	 EXEC("if(!EndlessStateSec)  ActKey(KEYON+UP+SecondaryFire);"),		// IM, OM
								0,	 EXEC("if(!EndlessStateSec)  ActKey(KEYON+UP+SecondaryFire);")); }	// ID, OD
	if(SecFirePinkyPref == 1) {
		MapKey(&Joystick,  S3,	TEMPO(PULSE+PinkyBtnDefaultShort, PULSE+PinkyBtnDefaultLong, LongPressDelay)); }	// Pinky Button			[USER DEFINED] [Short/Long: Set in User Preference]


	// DOUBLE-TAP PINKY TRIGGER //
	MapKey(&Joystick,  S4,		EXEC("initUserHotSlotPinkyTrigger();")); 											// Trigger 3 [Pinky Trigger] [Modifier Key]	[DO NOT REMAP!]
	MapKeyR(&Joystick, S4,		EXEC("ActKey(KEYON+UP+PinkyTriggerDefault);"
									 "if(PTModifier == 1 & fSRV) ActKey(KEYON+PULSE+SRVHandbrake);"));														// Release Pinky Trigger [Modifier Key] (Disable with // if using the line below)
//	MapKeyR(&Joystick, S4,		UP+UserDTPinkyKeyBind);																// Release ALT (enable by removing the //, if Double Tap Pinky Trigger mapping needs a 'Hold' action)


	// COMMS CONTROL PANEL HAT SWITCH (NON-VOICE) //
	MapKeyIOUMD(&Joystick,  H1U,																					// Trim Switch UP
								EXEC("initSendChatString(chat_Modifier_UP);"),				// IU
								EXEC("initSendChatString(chat_Basic_UP);"),					// OU
								EXEC("ActKey(KEYON+PULSE+mReportCrimesToggle);"),			// IM
								EXEC("ActKey(KEYON+PULSE+WingmanTarget);"),					// OM
								EXEC("ActKey(KEYON+PULSE+FighterFocusAttack);"),			// ID
								EXEC("ActKey(KEYON+PULSE+FighterAggressive);"));			// OD
	MapKeyIOUMD(&Joystick,  H1D,																					// Trim Switch DOWN
								EXEC("initSendChatString(chat_Modifier_DOWN);"),			// IU
								EXEC("initSendChatString(chat_Basic_DOWN);"),				// OU
								EXEC("ActKey(KEYON+PULSE+WingmanNavlock);"),				// IM
								EXEC("ActKey(KEYON+PULSE+SelectWingman2);"),				// OM
								EXEC("ActKey(KEYON+PULSE+FighterDock);"),					// ID
								EXEC("ActKey(KEYON+PULSE+FighterOrders);"));				// OD
	MapKeyIOUMD(&Joystick,  H1L,																					// Trim Switch LEFT
								EXEC("initSendChatString(chat_Modifier_LEFT);"),			// IU
								EXEC("initSendChatString(chat_Basic_LEFT);"),				// OU
								EXEC("ActKey(KEYON+PULSE+mNAVBeaconOff);"),					// IM
								EXEC("ActKey(KEYON+PULSE+SelectWingman1);"),				// OM
								EXEC("ActKey(KEYON+PULSE+FighterHoldPosition);"),			// ID
								EXEC("ActKey(KEYON+PULSE+FighterDefensive);"));				// OD
	MapKeyIOUMD(&Joystick,  H1R,																					// Trim Switch RIGHT
								EXEC("initSendChatString(chat_Modifier_RIGHT);"),			// IU
								EXEC("initSendChatString(chat_Basic_RIGHT);"),				// OU
								EXEC("ActKey(KEYON+PULSE+mNAVBeaconWing);"),				// IM
								EXEC("ActKey(KEYON+PULSE+SelectWingman3);"),				// OM
								EXEC("ActKey(KEYON+PULSE+FighterHoldFire);"),				// ID
								EXEC("ActKey(KEYON+PULSE+FighterFollow);"));				// OD

																													// Data Management Switch (DMS): Advanced PIP Selection (4 Configurations)
	// PIP CONFIG //																								//    [NOTE: Set UserPIPPref in the AD_EDUserPrefs.tmh file]
	if(UserPIPPref == 0) {																							// DOUBLE-TIER (INVERTED) [Inc. short & long press, no modifier]
		MapKey(&Joystick, PUP, TEMPO(EXEC("if(!Joystick[S4]) initPIPMapper(ENG,SYS);"								// DMS UP (H3U)	  [Short: 4xENG 2xSYS]
										  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioPlayPause);"),			// [Short+Pinky: GalNet Audio Play/Pause]
									 EXEC("if(!Joystick[S4]) ActKey(KEYON+PULSE+PowerEng);"							// [Long: 1xENG]
									 	  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioPlayPause);"),			// [Long+Pinky:  GalNet Audio Play/Pause]
																								PIPPressDelay));
		MapKey(&Joystick, PDN, TEMPO(EXEC("if(!Joystick[S4]) initPIPMapper(SYS,WEP,MID);"),							// DMS DOWN (H3D) [Short: 3xSYS 3xWEP]
									 EXEC("if(!Joystick[S4]) ActKey(KEYON+PULSE+BalancePower);"						// [Long: Balance]
									 	  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioClearQueue);"),			// [Long+Pinky:  GalNet Audio Clear Queue]
																								PIPPressDelay));
		MapKey(&Joystick, PLT, TEMPO(EXEC("if(!Joystick[S4]) initPIPMapper(SYS,WEP);"								// DMS LEFT (H3L) [Short: 4xSYS 2xWEP]
										  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioPrev);"),				// [Short+Pinky: GalNet Audio Previous Track]
									 EXEC("if(!Joystick[S4]) ActKey(KEYON+PULSE+PowerSys);"							// [Long: 1xSYS]
									 	  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioPrev);"),				// [Long+Pinky:  GalNet Audio Previous Track]
									 	  														PIPPressDelay));	
		MapKey(&Joystick, PRT, TEMPO(EXEC("if(!Joystick[S4]) initPIPMapper(WEP,ENG);"								// DMS RIGHT (H3R) [Short: 4xWEP 2xSYS]
										  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioNext);"),				// [Short+Pinky: GalNet Audio Next Track]
									 EXEC("if(!Joystick[S4]) ActKey(KEYON+PULSE+PowerWep);"							// [Long: 1xWEP]
									 	  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioNext);"),				// [Long+Pinky:  GalNet Audio Next Track]
																								PIPPressDelay)); }
	if(UserPIPPref == 1) {																							// STANDARD SINGLE-TIER PIPS [*Elite Dangerous Default Functionality*]
		MapKey(&Joystick, PUP, EXEC(	  "if(!Joystick[S4]) ActKey(KEYON+PULSE+PowerEng);"							// DMS UP (H3U)	 [Power to Engines (1 PIP)]
										  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioPlayPause);"));			// [Short+Pinky: GalNet Audio Play/Pause]
		MapKey(&Joystick, PDN, TEMPO(EXEC("if(!Joystick[S4]) ActKey(KEYON+PULSE+BalancePower);"),					// DMS DOWN (H3D)[Balance Power	 (1 PIP)]
									 EXEC("if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioClearQueue);"),			// [Long+Pinky:  GalNet Audio Clear Queue]
																								PIPPressDelay));
		MapKey(&Joystick, PLT, EXEC(	  "if(!Joystick[S4]) ActKey(KEYON+PULSE+PowerSys);"							// DMS LEFT (H3L) [Power to Systems (1 PIP)]
										  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioPrev);"));				// [Short+Pinky: GalNet Audio Previous Track]
		MapKey(&Joystick, PRT, EXEC(	  "if(!Joystick[S4]) ActKey(KEYON+PULSE+PowerWep);"							// DMS RIGHT (H3R) [Power to Weapons (1 PIP)]
										  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioNext);")); }				// [Short+Pinky: GalNet Audio Next Track]

	if(UserPIPPref == 2) {																							// DOUBLE-TIER PIPS       [Inc. short & long press, no modifier]
		MapKey(&Joystick, PUP, TEMPO(EXEC("if(!Joystick[S4]) ActKey(KEYON+PULSE+PowerEng);"							// DMS UP (H3U)   [Short: 1xENG]
										  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioPlayPause);"),			// [Short+Pinky: GalNet Audio Play/Pause]
									 EXEC("if(!Joystick[S4]) initPIPMapper(ENG,SYS);"								// [Long: 4xENG 2xSYS]
									 	  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioPlayPause);"),			// [Long+Pinky:  GalNet Audio Play/Pause]
																								PIPPressDelay));
		MapKey(&Joystick, PDN, TEMPO(EXEC("if(!Joystick[S4]) ActKey(KEYON+PULSE+BalancePower);"),					// DMS DOWN (H3D) [Short: Balance]	
									 EXEC("if(!Joystick[S4]) initPIPMapper(SYS,WEP,MID);"							// [Long: 3xSYS 3xWEP]
									 	  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioClearQueue);"),			// [Long+Pinky:  GalNet Audio Clear Queue]
																								PIPPressDelay));
		MapKey(&Joystick, PLT, TEMPO(EXEC("if(!Joystick[S4]) ActKey(KEYON+PULSE+PowerSys);"							// DMS LEFT (H3L) [Short: 1xSYS]
										  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioPrev);"),				// [Short+Pinky: GalNet Audio Previous Track]
									 EXEC("if(!Joystick[S4]) initPIPMapper(SYS,WEP);"								// [Long: 4xSYS 2xWEP]
									 	  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioPrev);"),				// [Long+Pinky:  GalNet Audio Previous Track]
									 	  														PIPPressDelay));
		MapKey(&Joystick, PRT, TEMPO(EXEC("if(!Joystick[S4]) ActKey(KEYON+PULSE+PowerWep);"							// DMS RIGHT (H3R) [Short: 1xWEP]
										  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioNext);"),				// [Short+Pinky: GalNet Audio Next Track]
									 EXEC("if(!Joystick[S4]) initPIPMapper(WEP,ENG);"								// [Long: 4xWEP 2xENG]
									 	  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioNext);"),				// [Long+Pinky:  GalNet Audio Next Track]
																								PIPPressDelay)); }
	if(UserPIPPref == 3) {																							// TRIPLE-TIER PIPS       [Inc. short/medium/long presses, no modifier]
		MapKey(&Joystick, PUP, TEMPO(EXEC("if(!Joystick[S4]) ActKey(KEYON+PULSE+PowerEng);"							// DMS UP (H3U)	  [Short: 1xENG]
									 	  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioPlayPause);"),			// [Short+Pinky: GalNet Audio Play/Pause]
						 	   TEMPO(EXEC("if(!Joystick[S4]) initPIPMapper(ENG,SYS);"								// [Med:  4xENG 2xSYS]
									 	  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioPlayPause);"),			// [Med+Pinky:  GalNet Audio Play/Pause]
									 EXEC("if(!Joystick[S4]) initPIPMapper(ENG,WEP);"								// [Long: 4xENG 2xWEP]
								 		  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioPlayPause);"),			// [Long+Pinky:  GalNet Audio Play/Pause]
									 				 	  										PIPPressDelay), PIPPressDelay));
		MapKey(&Joystick, PDN, TEMPO(EXEC("if(!Joystick[S4]) ActKey(KEYON+PULSE+BalancePower);"),					// DMS DOWN (H3D) [Short: Balance]
							   TEMPO(EXEC("if(!Joystick[S4]) initPIPMapper(SYS,WEP,MID);"),							// [Med: 3xSYS 3xWEP]
									 EXEC("if(!Joystick[S4]) initPIPMapper(ENG,WEP,MID);"							// [Long:  3xENG, 3xWEP]
										  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioClearQueue);"),			// [Long+Pinky:  GalNet Audio Clear Queue]
																								PIPPressDelay), PIPPressDelay));
		MapKey(&Joystick, PLT, TEMPO(EXEC("if(!Joystick[S4]) ActKey(KEYON+PULSE+PowerSys);"							// DMS LEFT (H3L) [Short: 1xSYS]
									 	  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioPrev);"),				// [Short+Pinky: GalNet Audio Previous Track]
							   TEMPO(EXEC("if(!Joystick[S4]) initPIPMapper(SYS,WEP);"								// [Med:  4xSYS 2xWEP]
									 	  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioPrev);"),				// [Med+Pinky:  GalNet Audio Previous Track]
									 EXEC("if(!Joystick[S4]) initPIPMapper(SYS,ENG);"								// [Long: 4xSYS 2xENG]
									 	  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioPrev);"),				// [Long+Pinky:  GalNet Audio Previous Track]
									 				 	  										PIPPressDelay), PIPPressDelay));
		MapKey(&Joystick, PRT, TEMPO(EXEC("if(!Joystick[S4]) ActKey(KEYON+PULSE+PowerWep);"							// DMS RIGHT (H3R) [Short: 1xWEP]
									 	  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioNext);"),				// [Short+Pinky: GalNet Audio Next Track]
							   TEMPO(EXEC("if(!Joystick[S4]) initPIPMapper(WEP,SYS);"								// [Med:  4xWEP 2xSYS]
									 	  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioNext);"),				// [Med+Pinky:  GalNet Audio Next Track]
									 EXEC("if(!Joystick[S4]) initPIPMapper(WEP,ENG);"								// [Long: 4xWEP 2xENG]
									 	  "if(Joystick[S4])  ActKey(KEYON+PULSE+GalNetAudioNext);"),				// [Long+Pinky:  GalNet Audio Next Track]
									 				 	  										PIPPressDelay), PIPPressDelay)); }


	// TMS HATSWITCH //
//	MapKey(&Joystick, H2U, 0); 																						// Target Management Switch (TMS) UP	(Mapped in ED Bindings File)
//	MapKey(&Joystick, H2D, 0);						<MAPPED IN BINDINGS>											// Target Management Switch (TMS) DOWN	(Mapped in ED Bindings File)
//	MapKey(&Joystick, H2L, 0); 																						// Target Management Switch (TMS) LEFT	(Mapped in ED Bindings File)
//	MapKey(&Joystick, H2R, 0); 																						// Target Management Switch (TMS) RIGHT	(Mapped in ED Bindings File)


	// CMS HATSWITCH //
//	MapKey(&Joystick, H4U, 0); 																						// Countermeasures Management Switch (CMS) UP	 (Mapped in ED Bindings File)
//	MapKey(&Joystick, H4D, 0); 																						// Countermeasures Management Switch (CMS) DOWN	 (Mapped in ED Bindings File)
//	MapKey(&Joystick, H4L, 0); 						<MAPPED IN BINDINGS>											// Countermeasures Management Switch (CMS) LEFT	 (Mapped in ED Bindings File)
//	MapKey(&Joystick, H4R, 0); 																						// Countermeasures Management Switch (CMS) RIGHT (Mapped in ED Bindings File)
//	MapKey(&Joystick, H4P, 0); 																						// Countermeasures Management Switch (CMS) PUSH	 (Mapped in ED Bindings File)


//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// MAP THROTTLE ARM CONTROLS
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	// BOOST & HARDPOINT BUTTONS //
	MapKey(&Throttle,  SC,   TEMPO(0, EXEC(																			// Slew Control Button
										"if(!Joystick[S4] & !Throttle[FLAPD] & !Throttle[IDLELON] & fSRV) ActKey(KEYON+DOWN+SRVVerticalThrust);"	  //   [Hold]
										"if(!Joystick[S4] & !Throttle[FLAPD] & !Throttle[IDLELON] & fMainShip) ActKey(KEYON+PULSE+EngineBoost);"	 //   [Press]
										"if(Joystick[S4]  & !Throttle[FLAPD] & !Throttle[IDLELON] & fMainShip) ActKey(KEYON+PULSE+mBoostBrake);"),	// [Modifier]
						     MiniPressDelay));																		// Safety: Won't Boost when in Precise Throttle or IDLE! Plus 150ms Delay :)
	MapKeyR(&Throttle, SC,   EXEC(		"ActKey(KEYON+UP+SRVVerticalThrust);"));									// Release the SRV Vertical Thrust


	MapKey(&Throttle,  LTB,  TEMPO(EXEC("initHardpointManagement();"),												// Left Throttle Button (RED)
								   EXEC("if(!Joystick[H4P] & !Joystick[S4]) ActKey(KEYON+DOWN+ShowCQCScoreboard);"),// If in CQC: Show Scoreboard (Hold) | If NOT in CQC: Reset Hardpoint Flag (fix alignment issues with Escape Vector Macro)
							 LongPressDelay));																		// [Have System selected prior to High Wake]
	MapKeyR(&Throttle, LTB,  EXEC(      "ActKey(KEYON+UP+ShowCQCScoreboard);"));									// Release CQC Scoreboard display

//	MapKey(&Throttle,  MSU,  0); 																					// Mic Switch UP	(Mapped in ED Bindings File)
//	MapKey(&Throttle,  MSD,  0); 					<MAPPED IN BINDINGS>											// Mic Switch DOWN	(Mapped in ED Bindings File)
//	MapKey(&Throttle,  MSL,  0); 																					// Mic Switch LEFT	(Mapped in ED Bindings File)
//	MapKey(&Throttle,  MSR,  0); 																					// Mic Switch RIGHT	(Mapped in ED Bindings File)
	MapKey(&Throttle,  MSP,  EXEC("initMicCommander();"));															// Mic Switch PUSH
	MapKeyR(&Throttle, MSP,  EXEC("initMicCommander();"));															// Mic Switch PUSH RELEASE

//	MapKey(&Throttle,  CSU,  0); 																					// Coolie Hat Switch UP 	(Mapped in ED Bindings File)
//	MapKey(&Throttle,  CSD,  0);					<MAPPED IN BINDINGS>											// Coolie Hat Switch DOWN	(Mapped in ED Bindings File)
//	MapKey(&Throttle,  CSL,  0); 																					// Coolie Hat Switch LEFT	(Mapped in ED Bindings File)
//	MapKey(&Throttle,  CSR,  0); 																					// Coolie Hat Switch RIGHT	(Mapped in ED Bindings File)


	// FLIGHT ASSIST MODE  //
	MapKey(&Throttle,  SPDF, EXEC("initEnhancedFAOFF();"));															// Speedbrake Forward TOGGLE ON
	MapKeyR(&Throttle, SPDF, EXEC("initEnhancedFAOFF();"));															// Speedbrake Forward TOGGLE RELEASE
	MapKey(&Throttle,  SPDB, EXEC("initEnhancedFAOFF();"));															// Speedbrake Back HOLD
	MapKeyR(&Throttle, SPDB, EXEC("initEnhancedFAOFF();"));															// Speedbrake Back RELEASE


	// NAVIGATION BOAT SWITCH //
	MapKey(&Throttle,  BSF,  EXEC("if(!Joystick[S4]) ActKey(KEYON+PULSE+GalaxyMap);" 								// Boat Switch Throttle FORWARD
								  "if(Joystick[S4])  initFreeCameraModeUpgrade();"));
	MapKey(&Throttle,  BSM,  EXEC("if(FreeModeHat)   initFreeCameraModeUpgrade();" 									// Boat Switch Throttle MIDDLE		[Centering Switch will Exit Maps]
								  "if(!FreeModeHat)  ActKey(KEYON+PULSE+UIBack);"));
	MapKey(&Throttle,  BSB,  PULSE+SystemMap); 																		// Boat Switch Throttle BACK


	// CRUISE ON THROTTLE CONFIG //
	if(CruiseOnThrottle == 0) {																						// Sets China Hat to add Frame Shift Drive when Cruise on Throttle is disabled.
		MapKey(&Throttle,  CHF, TEMPO(FrameShiftDrive, Supercruise, LongPressDelay)); 								// China Hat FORWARD [When Route Blocked HOLD for Supercruise]
		MapKey(&Throttle,  CHB, TEMPO(EXEC(																			// China Hat BACK 	 [Short: Night Vision or Orbital Lines(+Pinky), Very Long: Next Sys Route]
										"if(Joystick[S4])  ActKey(KEYON+PULSE+OrbitalLines);"
										"if(!Joystick[S4]) initNightVisionEnhancer();"),
									  EXEC(
									  	"if(Joystick[S4])  initAutoVehicleTransition();"
									 	"if(!Joystick[S4] & fMainShip) ActKey(KEYON+PULSE+SelectNextSystemInRoute);"
										"if(!Joystick[S4] & fSRV) ActKey(KEYON+PULSE+SRVHandbrake);"), LongPressDelay)); }
	if(CruiseOnThrottle == 1) {																						// Sets China Hat to remove Frame Shift Drive when Cruise on Throttle is enabled.
		MapKey(&Throttle,  CHF, EXEC(																				// China Hat FORWARD
										"if(Joystick[S4])  ActKey(KEYON+PULSE+OrbitalLines);"
										"else			   initNightVisionEnhancer();"));
		MapKey(&Throttle,  CHB,  EXEC(	"if(Joystick[S4])  initAutoVehicleTransition();"							// China Hat BACK
										"if(!Joystick[S4] & fMainShip) ActKey(KEYON+PULSE+SelectNextSystemInRoute);"
										"if(!Joystick[S4] & fSRV) ActKey(KEYON+PULSE+SRVHandbrake);")); }


	// SHIFT KEY ADDITIONAL MAPPINGS //
	MapKey(&Throttle,  PSF,  EXEC(																					// Pinky Throttle Switch FORWARD
								"if(Joystick[H4P] & fSRV) PTModifier = 1;" 
								"if(Joystick[H4P] & !fSRV) ActKey(KEYON+PULSE+mJumpNextSubSys);"
								"if(Joystick[S4] & SquadronClearPanel)	ActKey(KEYON+PULSE+mClearChatBoxesSquadron);"
								"if(Joystick[S4] & !SquadronClearPanel) ActKey(KEYON+PULSE+mClearMainChatBoxes);"
								"if(!Joystick[S4] & !Joystick[H4P] & VerboseOutput & !fSRV) { printf(\"SHIFT KEY FORWARD  >>> [Comms Channel: AUTO-TEXT]\\x0a\"); printf(\"SHIFT KEY FORWARD  >>> [Repeater Mode: COMBAT-ENDLESS]\\x0a\"); }"));
	MapKeyR(&Throttle,  PSF,  EXEC(																					// Pinky Throttle Switch FORWARD
								"if(Joystick[H4P]) PTModifier = 0;"));

	MapKey(&Throttle,  PSM,  EXEC( 																					// Pinky Throttle Switch MIDDLE
								"if(Joystick[H4P] & !fSRV) ActKey(KEYON+PULSE+mJumpMidSubSys);"
								"if(!Joystick[S4] & !Joystick[H4P] & VerboseOutput & !fSRV) { printf(\"SHIFT KEY MIDDLE  ---- [Comms Channel: WINGS]\\x0a\"); printf(\"SHIFT KEY MIDDLE  ---- [Repeater Mode: EXPLORER-SCANNER]\\x0a\"); }"));
	MapKey(&Throttle,  PSB,  EXEC(																					// Pinky Throttle Switch BACK
								"if(Joystick[H4P] & !fSRV) ActKey(KEYON+PULSE+mJumpPrevSubSys);"
								"if(Joystick[S4])  ActKey(KEYON+PULSE+HideShipGUI);"
								"if(!Joystick[S4] & !Joystick[H4P] & VerboseOutput & !fSRV) { printf(\"SHIFT KEY BACKWARD <<< [Comms Channel: FIGHTER]\\x0a\"); printf(\"SHIFT KEY BACKWARD <<< [Repeater Mode: MINING-AUTO-PULSE]\\x0a\"); }"));
	MapKeyR(&Throttle, PSB,  EXEC(																					// Pinky Throttle Switch BACK RELEASE
								"if(Joystick[S4])  ActKey(KEYON+PULSE+HideShipGUI);"));


//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// MAP THROTTLE BASE CONTROLS
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	// AUX. OSD & REPORT CRIMES GAME CONTROLS //
	MapKey(&Throttle,  EFLNORM,  EXEC(																				// Engine Fuel Flow Norm/Override Switches LEFT
									 "if(!Joystick[S4] & !ShowGameStatState) ActKey(KEYON+PULSE+mShowGameStats);"
									 "if(!Joystick[S4] & !ShowGameStatState) ShowGameStatState = 1;"
									 "if(Joystick[S4]  & !ReportCrimeState)	 ActKey(KEYON+PULSE+mReportCrimesToggle);"
									 "if(Joystick[S4]  & !ReportCrimeState)  ReportCrimeState = 1;"));
	MapKeyR(&Throttle, EFLNORM,  EXEC(																				// Engine Fuel Flow Norm/Override Switches LEFT RELEASE
									 "if(!Joystick[S4] & ShowGameStatState)  ActKey(KEYON+PULSE+mShowGameStats);"
									 "if(!Joystick[S4] & ShowGameStatState)  ShowGameStatState = 0;"
									 "if(Joystick[S4]  & ReportCrimeState)   ActKey(KEYON+PULSE+mReportCrimesToggle);"
								 	 "if(Joystick[S4]  & ReportCrimeState)   ReportCrimeState = 0;"));
	MapKey(&Throttle,  EFLOVER,  0); 																				// Engine Fuel Flow Norm/Override Switches LEFT OFF


	// VOICE COMMS CHANNEL SELECTION //
	MapKey(&Throttle,  EFRNORM,  EXEC("if(VerboseOutput) printf(\"Voice Comms: !!  EXTERNAL CHANNELS SELECTED  !!\\x0a\");")); 		// Engine Fuel Flow Norm/Override Switches RIGHT 		[Mic Toggle ON (External/3rd Party)]
//	MapKeyR(&Throttle, EFRNORM,  0); 																				// Engine Fuel Flow Norm/Override Switches RIGHT RELEASE 
	MapKey(&Throttle,  EFROVER,  EXEC("if(VerboseOutput) printf(\"Voice Comms: !!  E:D INTERNAL CHANNEL SELECTED  !!\\x0a\");"));	// Engine Fuel Flow Norm/Override Switches RIGHT OFF 	[Mic Toggle OFF (Internal/Default)]


	// AUX. HEADLOOK & OPEN MIC GAME CONTROLS //
	MapKey(&Throttle,  EOLIGN,   TEMPO(EXEC("initHeadlookModeSelect();"),	PULSE+TrackIRPause, LongPressDelay));	// Engine Operate Ign/Norm LEFT UP [Short: TIR/VR Center] [Long: TIR Pause]
	MapKey(&Throttle,  EOLNORM,  0); 																				// Engine Operate Ign/Norm LEFT OFF
	MapKey(&Throttle,  EOLMOTOR, EXEC("initMicCommander();"));														// Engine Operate Ign/Norm LEFT DOWN	[Toggle between Push-To-Talk & Open Comms]
	MapKeyR(&Throttle, EOLMOTOR, EXEC("initMicCommander();"));														// Engine Operate Ign/Norm LEFT RELEASE


	// SHIP FEATURE FUNCTIONS //
	MapKey(&Throttle,  EORIGN,   TEMPO(EXEC(																		// Engine Operate Ign/Norm RIGHT UP
										"if(!Joystick[S4] & !Joystick[H4P]) initToggleShipLights(1);"				// If no Modifier held, default Ship Lights
										"if(Joystick[S4])  ActKey(KEYON+PULSE+mChangeColours);"),					// If Modifier held, Change Weapon & Engine Color
							     PULSE+ShipLights, LongPressDelay));												// [Long: Reset Ship Lights (when out of sync)]
	MapKey(&Throttle,  EORNORM,  0); 																				// Engine Operate Ign/Norm RIGHT OFF
	MapKey(&Throttle,  EORMOTOR, EXEC("initToggleRotationCorrection();"));											// Engine Operate Ign/Norm RIGHT DOWN
	MapKeyR(&Throttle, EORMOTOR, EXEC("initToggleRotationCorrection();")); 											// Engine Operate Ign/Norm RIGHT RELEASE

	MapKey(&Throttle,  APUON,	 EXEC("initToggleSilentRunning(1);")); 												// APU START UP
	MapKeyR(&Throttle, APUON,	 EXEC("initToggleSilentRunning(0);")); 												// APU START RELEASE
	MapKey(&Throttle,  APUOFF,	 0); 																				// APU OFF DOWN


	// EXTERNAL HOTKEY CONTROLS //
	MapKey(&Throttle,  LDGH, 	 TEMPO(EXEC(																		// Landing Gear/Warning Silence Button 
								  	"if(!Joystick[S4]) ActKey(KEYON+PULSE+TakeSteamScreenshot);"					// [Short: 		 Steam Screenshot]
								  	"if(Joystick[S4])  ActKey(KEYON+PULSE+HighResScreenshot);"),					// [Short+Pinky: Hi-Res Screenshot (Solo/Private Modes only)] 
								 EXEC(
								  	"if(!Joystick[S4]) ActKey(KEYON+PULSE+GPUCaptureVideoAuto);" 					// [Long: 		 Save Last xx mins Video Capture]
								  	"if(Joystick[S4])  ActKey(KEYON+PULSE+GPUCaptureManual);"), 					// [Long+Pinky:  Manual Start/Stop Video Capture]
								 ExtraPressDelay));	


	// LANDING GEAR & CARGO SCOOP //
	MapKey(&Throttle,  EACON, 	 EXEC("initToggleLandingGear(1);")); 												// EAC ARM UP
	MapKeyR(&Throttle, EACON,	 EXEC("initToggleLandingGear(0);"));												// EAC ARM UP RELEASE
	MapKey(&Throttle,  EACOFF,	 0); 																				// EAC OFF DOWN

	MapKey(&Throttle,  RDRNRM,	 EXEC("initToggleCargoScoop(1);"));													// RDR ALTM NRM UP [Deploy Cargo Scoop]
	MapKeyR(&Throttle, RDRNRM,	 EXEC("initToggleCargoScoop(0);"));													// RDR ALTM NRM UP REVERSE
	MapKey(&Throttle,  RDRDIS,	 0);


	// AUTOPILOT BUTTON CUSTOM CONFIGURATOR //
	MapKey(&Throttle,  APENG,	 TEMPO(EXEC("APSeqShort = 1;" "initAPEngageEnhancer();"),							// Autopilot Engage Button 
									   EXEC("APSeqLong  = 1;" "initAPEngageEnhancer();"),
								 LongPressDelay));
//	MapKey(&Throttle,  APDIS,	 0); 																				// Autopilot Disengage Button


	// IDLE LOCK CONFIG //
	MapKey(&Throttle,  IDLELON,	 EXEC("initIDLEMaster();" "if(VerboseOutput) printf(\"THROTTLE IDLE LOCK: ^^ACTIVE^^\\x0a\");"));		// Throttle Idle Detents LEFT ON	[Locking (Down): Stationary]
	MapKeyR(&Throttle, IDLELON,  EXEC("initIDLEMaster();" "if(VerboseOutput) printf(\"THROTTLE IDLE LOCK: *DISABLED*\\x0a\");"));		// Throttle Idle Detents LEFT ON RELEASE
//	MapKey(&Throttle,  IDLELOFF, 0);																				// Throttle Idle Detents LEFT OFF
//	MapKey(&Throttle,  IDLERON,  0); 				<NOT USED>														// Throttle Idle Detents RIGHT ON			(Not used)
//	MapKeyR(&Throttle, IDLERON,  0);																				// Throttle Idle Detents RIGHT ON RELEASE	(Not used)
//	MapKey(&Throttle,  IDLEROFF, 0); 																				// Throttle Idle Detents RIGHT OFF			(Not used)

	printf("Done... Enhanced ED Script Engineered by Aussiedroid is now running...    Fly Safe CMDR!	       <|>\x0a");
	printf("-----------------------------------------------------------------------------------------------------------------------------------------------");
	
	StartupLock = 0;																								// Startup Pre-checks: "Releases" the Startup Lock post initialising the Macros/Functions/Hardware above.
} 																													// end main()


//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// EVENT HANDLER //
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	int EventHandle(int type, alias o, int x) {
		int LED_BRT, TRPCOMBO, Differential_Toe;

		if (&o == &Throttle & x == THR_FC & Joystick[S4]) {									// Throttle: LED On-The-Fly Backlight Control
			LED_BRT = (AxisVal(Throttle[THR_FC], &axdata) - 32766) / 256 * -1;				// HOLD S4 (Pinky Trigger) on Joystick & Move Friction Control Axis
			ActKey(PULSE+KEYON+LED (&Throttle, LED_INTENSITY, LED_BRT)); }
		DefaultMapping(&o, x);

		if(UseRuddersT16000 == 1) {															// TFRP Rudder: Maps the MODE_FILTERED through Target
			if (&o == &TFRPRudder) {  														// 			   (We can Trim, set Deadzones, J/Scurves, etc.)
				GetAxisData(&o, x);															//	   X Axis = Differential combined Toe Brakes, rest at center
				if(x == TRPLEFT | x == TRPRIGHT) {											// 	   Y Axis = Both Toe Brakes pressed at same time, rest at 0
					axdata.locked = 1;														// 	   Z Axis = Rudder (as default)
					Differential_Toe = -TFRPRudder[TRPRIGHT]/2 + TFRPRudder[TRPLEFT]/2;
					GameOutput(&o, TRPRIGHT, AxisVal(Differential_Toe, &axdata));
					if  (TFRPRudder[TRPLEFT] < TFRPRudder[TRPRIGHT]) TRPCOMBO = TFRPRudder[TRPRIGHT];
					else TRPCOMBO = TFRPRudder[TRPLEFT];
					GameOutput (&o, TRPLEFT, AxisVal(-TRPCOMBO, &axdata)); }
				if(!axdata.locked & !axdata.relative) GameOutput(&o, x, AxisVal(o[x], &axdata)); } }
				
		if(UseRuddersTPR == 1) {															// TFRPHA Rudder: Maps the MODE_FILTERED through Target
			if (&o == &TFRPHARudder) {  													// 			   (We can Trim, set Deadzones, J/Scurves, etc.)
				GetAxisData(&o, x);															//	   X Axis = Differential combined Toe Brakes, rest at center
				if(x == TFRPHA_LEFT | x == TFRPHA_RIGHT) {									// 	   Y Axis = Both Toe Brakes pressed at same time, rest at 0
					axdata.locked = 1;														// 	   Z Axis = Rudder (as default)
					Differential_Toe = -TFRPHARudder[TFRPHA_RIGHT]/2 + TFRPHARudder[TFRPHA_LEFT]/2;
					GameOutput(&o, TFRPHA_RIGHT, AxisVal(Differential_Toe, &axdata));
					if  (TFRPHARudder[TFRPHA_LEFT] < TFRPHARudder[TFRPHA_RIGHT]) TRPCOMBO = TFRPHARudder[TFRPHA_RIGHT];
					else TRPCOMBO = TFRPHARudder[TFRPHA_LEFT];
					GameOutput (&o, TFRPHA_LEFT, AxisVal(-TRPCOMBO, &axdata)); }
				if(!axdata.locked & !axdata.relative) GameOutput(&o, x, AxisVal(o[x], &axdata)); } } }


//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//------------------------------//
//  "I am a leaf on the wind!"  //
//------------------------------//