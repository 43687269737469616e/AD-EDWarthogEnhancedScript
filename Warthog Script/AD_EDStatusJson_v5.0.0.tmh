//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// STATUS.JSON PARSER: Determine the Real-time Status of In-game Commands, via the ED Log file.								Original Author: CMDR Clicker		//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// GLOBAL VARIABLES	//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	char myJson;								 							// Char array to store status.json

//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// STATUS 'READ/PROCESS' FUNCTIONS	//										Requires:	'StatusFile' alias must be set correctly in AD_EDUserPrefs.tmh
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	int fnReadStatusJson() {												// FUNCTION: Read status.json into 'myJson'

		int	fp;																// General purpose file handle
		int	buf = 512;														// Buffer variable. status.json can get lengthy, so assign a buffer of at least 512
		int	myResult;														// General pupose 'result' variable

		Dim(&myJson, buf);													// Dimension our character array to size of buffer
		myJson[0] = 0;														// Best always to zero out the array before use
		fp = fopen(&StatusFile, "r");										// Open status.json for reading
		if (fp) {															// If we succeed in opening...
			myResult = fread(&myJson, 1, buf, fp);							// ...read the entire file into our character array (myJson)...
			fclose(fp);														// ... and close the file
			if (myResult == 0) 	{										// 'myResult' should contain the number of characters read...
				ReadErrorCount = ReadErrorCount + 1;
				if(VerboseOutput) printf("WARNING READ ERROR #%d: Status.json\x0a", ReadErrorCount); } // ...so, if we read zero, we had an issue!
			else {
				ReadErrorCount = 0;
				strdel(&myJson, myResult-1, buf); } }					// If no issues with read, remove any trailing garbage
		else {
			if(VerboseOutput) printf("FATAL ACCESS ERROR: Status.json .. !ABORT!\x0a");						// File not found OR locked by Elite Dangerous!
								Abort(); } }



	int fnProcessFlags() {													// FUNCTION: Read & Process "Flags" value from "status.json"
																			// Declare all required local variables
		int Flags = 0;														// contains the Flags key value integer.
		int EndValue = 0;													// Catch when we get to a space or comma
		int myResult;														// Temporary general purpose variable to capture results of file and string operations
		int chrpnt;															// Pointer to current character in string

		char thischr;														// Contains current character read during string search
		Dim(&thischr, 2);
		thischr[0] = 0;

		char keyvalue;														// Contains our Key Value when complete
		Dim(&keyvalue, 16);													// arbitrary size. Currently Flags integer value does not exceed 11 digits
		keyvalue[0] = 0;

		fnReadStatusJson();													// Get latest status.json
		int Start = 64;														// Flags key value always starts at char# 64 in status.json
																			// Flags key value always ends in a space if zero, else comma character
		chrpnt = 0;															// Reset character pointer

		while (EndValue == 0) {												// Start loop...
			strsub(&thischr, &myJson, Start+chrpnt, Start+chrpnt);			// Grab next character in 'myJson' and put it into 'thischr'
			myResult = strcmp(&thischr, " ");
			if (myResult == 0) EndValue = 1;								// End loop when we find a space
			myResult = strcmp(&thischr, ",");
			if (myResult == 0) EndValue = 1;								// End loop when we find a comma
			if (EndValue == 0) strcat(&keyvalue, &thischr);					// Otherwise, update keyvalue...
			chrpnt = chrpnt + 1; }											// ...Update character pointer, and loop
		Flags = ieval(&keyvalue);											// Convert string to integer when we finished the loop
		if(DebugOutput) printf("Flags Integer    =    %d\x0a", Flags);		// print the Flags integer value to the console
																			// TARGET uses 32 bit signed precision for its integers. Flags values larger than 2147483648 wrap around to negative number and means that bit 31 (fSRVHiBeam) is set.																		
		if (Flags == 0) {		
			if(GameLoaded == 1) {											// Detects when Game halts
				//GameLoaded = 0;
				if (VerboseOutput & ReadErrorCount > 5) { printf("FILE READ ERROR: Count Exceeded...\x0a"); }
				// <- SHUTDOWN LED DIM SEQUENCE
				ActKey(PULSE+KEYON+LED(&Throttle, LED_INTENSITY, 0));
				if(VerboseOutput & ReadErrorCount < 5) printf("EXITING Elite Dangerous .. Auto Script Shutdown Initiated .. Bye!");
				Abort(); } }												// EXIT: Force Stop of Script.
																
		if (Flags != 0) {													// If Flags == 0, it means the game has not started yet...
			if(GameLoaded == 0) GameLoaded = 1;								// Game started...as opposed to re-started.			
			if (Flags < 0)		fSRVHiBeam = 1;								// ... otherwise, test for bit 31 first, like so...
			else 				fSRVHiBeam = 0;

			fAltFromAvgRad		= ((Flags & ED_AltFromAvgRad) > 0);			// ...then assign the rest of the 'Flags' values using 'bitwise and' between Flags and a mask for each variable, like so...
			fCargoScoop			= ((Flags & ED_CargoScoopDeployed) > 0);
			fDanger				= ((Flags & ED_IsInDanger) > 0);
			fDocked				= ((Flags & ED_Docked) > 0);
			fFAOff				= ((Flags & ED_FlightAssistOff) > 0);
			fFighter			= ((Flags & ED_InFighter) > 0);
			fFSDCharging		= ((Flags & ED_FSDCharging) > 0);
			fFSDCooldown		= ((Flags & ED_FSDCooldown) > 0);
			fFuelScoop			= ((Flags & ED_ScoopingFuel) > 0);
			fHardpoints			= ((Flags & ED_HardpointsDeployed) > 0);
			fHUDAnalysis		= ((Flags & ED_HudInAnalysisMode) > 0);
			fInterdicted		= ((Flags & ED_BeingInterdicted) > 0);
			fInWing				= ((Flags & ED_InWing) > 0);
			fLanded				= ((Flags & ED_Landed) > 0);
			fLandingGear		= ((Flags & ED_LandingGearDown) > 0);
			fLatLong			= ((Flags & ED_HasLatLong) > 0);
			fLights				= ((Flags & ED_LightsOn) > 0);
			fLowFuel			= ((Flags & ED_LowFuel) > 0);
			fMainShip			= ((Flags & ED_InMainShip) > 0);
			fMassLocked			= ((Flags & ED_FSDMassLocked) > 0);
			fNightVision		= ((Flags & ED_NightVision) > 0);
			fOverHeating		= ((Flags & ED_OverHeating) > 0);
			fsdJump				= ((Flags & ED_FSDJump) > 0);	
			fSilentRunning		= ((Flags & ED_SilentRunning) > 0);
			fShieldsUp			= ((Flags & ED_ShieldsUp) > 0);
			fSRV				= ((Flags & ED_InSRV) > 0);
			fSRVDriveAssist		= ((Flags & ED_SRVDriveAssist) > 0);
			fSRVHandbrake		= ((Flags & ED_SRVHandbrake) > 0);
			fSRVTurretRetracted = ((Flags & ED_SRVTurretRetracted) > 0);
			fSRVTurretView		= ((Flags & ED_SRVTurret) > 0);
			fSupercruise		= ((Flags & ED_Supercruise) > 0);

			if(!fFAOff & !Throttle[SPDF] & !Throttle[SPDB]) ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED1));	// set LED 1 ON
			if(!fSilentRunning & !Throttle[APUON]) ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED3));				// set LED 3 OFF
			if(!fCargoScoop & !Throttle[RDRNRM]) ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED4));				// set LED 4 OFF
			if(!fLandingGear & !Throttle[EACON]) ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED5));				// set LED 5 OFF

			if(DebugOutput) {
				printf("\x0a\ Active Flags");								// Print any Flags which are set to 1
				printf("\x0a===============\x0a");
				if (fAltFromAvgRad)			printf("Radius-ALT\x0a");
				if (fCargoScoop)			printf("Cargo Scoop Deployed\x0a");
				if (fDanger)				printf("!!! DANGER !!!\x0a");
				if (fDocked)				printf("Docked\x0a");
				if (fFAOff)					printf("Flight Assist OFF\x0a");
				if (fFighter)				printf("In Fighter\x0a");
				if (fFSDCharging)			printf("FSD Charging\x0a");
				if (fFSDCooldown)			printf("FSD Cooldown\x0a");
				if (fFuelScoop)				printf("Fuel Scoop Deployed\x0a");
				if (fHardpoints)			printf("Hardpoints Deployed\x0a");
				if (fHUDAnalysis)			printf("AnalysisHUD\x0a");
				if (fInterdicted)			printf("Being Interdicted\x0a");
				if (fInWing)				printf("In Wing\x0a");
				if (fLanded)				printf("Landed on planet\x0a");
				if (fLandingGear)			printf("Landing Gear Deployed\x0a");
				if (fLatLong)				printf("Lat\\Lon available\x0a");
				if (fLights)				printf("Lights On\x0a");
				if (fLowFuel)				printf("Low Fuel\x0a");
				if (fMainShip)				printf("In MainShip\x0a");
				if (fMassLocked)			printf("FSD Masslocked\x0a");
				if (fNightVision)			printf("Night Vision\x0a");
				if (fOverHeating)			printf("Over Heating\x0a");
				if (fsdJump)				printf("Hyperjump\x0a");
				if (fSilentRunning)			printf("Silent Running\x0a");
				if (fShieldsUp)				printf("Shields Up\x0a");
				if (fSRV)					printf("In SRV\x0a");
				if (fSRVDriveAssist)		printf("SRV Drive Assist\x0a");
				if (fSRVHandbrake)			printf("SRV Handbrake\x0a");
				if (fSRVHiBeam)				printf("SRVHiBeam\x0a");
				if (fSRVTurretRetracted)	printf("SRV Turret Retracted\x0a");
				if (fSRVTurretView)			printf("SRV Turret View\x0a");
				if (fSupercruise)			printf("Supercruise Engaged\x0a");
				printf("===============\x0a"); } } }


	
	int fnStartCheck() {													// FUNCTION: Initial check to see if game is already running after we've restarted the script.
		int fp;						// file pointer (handle)
		int ValidStatusFile = 0;
		
		fp = fopen(&StatusFile, "r");
		
		if (fp) {
			fclose(fp);
			ValidStatusFile = 1;
			if(DebugOutput) { printf("\FILE LOAD SUCCESS: status.json file set correctly in AD_EDUserPrefs\x0a"); } }
		else {
			printf("\x0a\!!! FATAL ERROR !!!\x0a");
			printf("status.json file not found.\x0a");
			printf("Please set 'StatusFile' alias correctly in AD_EDUserPrefs file\x0a");
			printf("Refer AD_EDUserPrefs.tmh file for instructions.\x0a");
			abort(); }
		if (ValidStatusFile) {
			fnReadStatusJson();
			if(VerboseOutput) printf("Processing Status.json flags...Now running...Done\x0a");
			ActKey(KEYON+REXEC(3, StatusReadRate, "fnProcessFlags();", RNOSTOP)); } }	// StatusReadRate is set in AD_EDDefaults.tmh


//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
